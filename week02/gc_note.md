
# GC学习体会

## GC中的不变

### GC基本算法

从Serial -> Par -> CMS -> G1 -> ZGC, GC的方法再不断优化迭代，但其基本的算法思想是不变的，其优缺点也是一直成立的。

**标记-清除（Mark-Sweep）**：优点简单高效，但会产生"千疮百孔"的内存碎片，导致大对象分配不到足够的连续内存。
因此不能全局使用。必须结合标记-复制， 将GC存活下来的对象复制到另一个区域，也就有了Eden区/Survivor区。

**标记-复制（Mark-Copy）**：优点是解决了标记-清除法的内存碎片问题，回收后内存空间连续。
缺点是需要将内存划分成多个区域相互拷贝，降低了有效内存，例如ParNewGC年轻代总会浪费一个Survivor区。
而且在对象回收率较低的时候，会涉及大量对象的复制，效果变差。

**标记-整理（Mark-Compact）**：优点是可以解决标记-复制法的问题，原地将剩余对象进行规整，同样可以清理出连续的大内存，
同时降低了对象回收率低的情况的性能衰退。但相应的，标记-整理有稍微复杂的偏移量计算，效率较比标记-清理，标记-复制差一些。

所以，实际的GC不会单一使用某一种算法，而是根据内存对象的生命周期/大小特点，采取内存分块，综合利用多种算法，达到整体的最优方案。

PS：CMS使用的是标记-清除算法，之前有误解。CMS对老年代不进行整理，而是使用空闲列表（free-lists）来管理内存的回收。
CMS的关键优化在于并发，让尽可能多的步骤可并发，以减少STW时间。

### 吞吐量 vs 延迟

选择GC方法和调优所关注的指标是不变的即**吞吐量**和**延迟**，两者在相同情况下是矛盾的，需要进行trade-off。
进行优化，首先要分析业务的瓶颈在哪里，确定优化的方向，优化就有的放矢。

新的GC方法：CMS->G1->ZGC。优先解决的问题是延迟，即令STW时间尽可能降低和可控。
相应的，更精细的控制逻辑意味着吞吐量的下降，因此使用新的GC算法不一定是最好的。
对于不需要交互的离线计算任务，也许用ParallelGC更好。

### 串行（Serail） -> 并行（Parallel） -> 并发（Concurrent）

主要是并行和并发的区别：
并行指的是有GC过程由单线程变为多线程，提高GC的吞吐。典型是SerailGC->ParNewGC
并发指的是业务逻辑和GC逻辑的同时进行。典型是CMS的产生。
由于先后出现的原因，并发收集器都是并行的。

### GC方法及特征表


|  GC方法   | 串行，并行，并发  | 新生代，老年代 | 算法 | 目标 | 适用场景 |
|  ----  | ----  | ---- | ---- | ---- | ---- |
| Serial  | 串行 | 新生代  | 标记-复制 | 延迟优先  | 单CPU的Client模式 |
| Serial Old  | 串行 | 老年代  | 标记-整理 | 延迟优先  | 单CPU的Client模式 |
| Par New  | 并行 | 新生代  | 标记-复制 | 延迟优先  | 多CPU的Server模式与CMS配合 |
| Par Scavenge  | 并行 | 新生代  | 标记-复制 | 吞吐量优先  | 后台运行不需要太多交互的场景 |
| Par Old  | 并行 | 老年代  | 标记-整理 | 延迟优先  | 后台运行不需要太多交互的场景 |
| CMS  | 并发 | 老年代  | 标记-清除 | 延迟优先  | 互联网B/S服务后端 |
| G1  | 并发 | both  | 标记-整理 + 标记-复制 | 延迟优先  | 替换CMS |


## CMS -> G1GC

目前最关键两种GC方式。

### CMS

Initial Mark

Concurrent Mark

Concurrent Preclean

Concurrent Abortable Preclean

Final Remark

Concurrent Sweep

Concurrent Reset


### G1

Initial Mark

Root Region Scan

Concurrent Mark

Remark

Cleanup




